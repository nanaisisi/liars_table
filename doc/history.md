# Liar's Table - 実装経緯

## 2025 年 7 月 26 日 - プロジェクト開始

### 背景

トランプを使ったロシアンルーレットゲーム「Liar's Table」の CLI ツールを実装することになった。
このゲームは以下の特徴を持つ：

- ACE、QUEEN、KING、JOKER 各 4 枚（計 16 枚）を使用
- 任意の人数で 5 枚ずつ配分
- プレイヤーは自分のテーブル（手札）から複数枚を伏せて出す
- 出したカードが正しい種類（ACE、QUEEN、KING）か JOKER でなければならない
- 他のプレイヤーが「Liar」だと思った場合、指摘できる
- 指摘が当たっていれば指摘対象が、間違っていれば指摘者がロシアンルーレット

### 初期設計方針（Phase 1）

1. **実際のトランプカードと併用**：物理的なトランプゲームの補助ツールとして機能
2. **CLI インターフェース**：シンプルで使いやすいコマンドライン操作
3. **モジュラー設計**：テーブル決定、装弾数指定、ロシアンルーレット判定を分離

### 技術選択

- **言語**: Rust - メモリ安全性と高性能を両立
- **アーキテクチャ**: コマンドライン引数による機能選択
- **乱数生成**: 暗号学的に安全な乱数生成器を使用予定

## 2025 年 7 月 26 日 午後 - 設計の大幅な見直し

### 問題認識

初期実装を完了したが、実際の使用を想定すると以下の問題が判明：

1. **カード管理の不要性**：実際にトランプを使用するため、プログラムがカード配布を管理する必要がない
2. **ユーザビリティの問題**：コマンドライン引数ベースは複数プレイヤーでの使用に不適
3. **国際化の必要性**：多様なユーザーに対応するため多言語対応が必要
4. **プレイヤー識別の問題**：Player 1, Player 2 では実際のプレイヤーが分からない
5. **ロシアンルーレット仕様の複雑さ**：実弾数と装弾数の概念が混乱を招く

### 新しい設計方針（Phase 2）

#### A. ゲーム設計の根本的変更

**変更前**：

- プログラムがカード配布・手札管理を行う
- デバッグ用のシステムエミュレーション

**変更後**：

- 実際のトランプカードを使用
- プログラムは純粋に補助ツールとして機能
- カード管理機能は削除またはオプション化

#### B. UI/UX の抜本的改革

**変更前**：

```bash
liars_table play --player 1 --cards 1,2 --declare ace
```

**変更後**：

- 対話式 UI
- プレイヤーが一人で操作し、他のプレイヤーに結果を公開
- 自然な会話フローでゲーム進行

#### C. 多言語対応の実装

**新機能**：

- 起動時の言語選択
- TOML 形式での言語設定管理
- 言語 ID ベースのメッセージ管理

**設計例**：

```toml
[languages.ja]
name = "日本語"
welcome = "Liar's Tableへようこそ！"
select_language = "言語を選択してください"

[languages.en]
name = "English"
welcome = "Welcome to Liar's Table!"
select_language = "Please select language"
```

#### D. プレイヤー管理の改善

**変更前**：

- 固定的な Player 1, Player 2, Player 3

**変更後**：

- カスタム名前設定
- ゲーム中の名前変更機能
- プレイヤー番号と名前の明確な紐づけ

**実装例**：

```
プレイヤー設定：
1: 太郎
2: 花子
3: 次郎

名前を変更しますか？ (y/N): y
変更するプレイヤー番号: 2
新しい名前: はなちゃん
```

#### E. ロシアンルーレット仕様の簡素化

**変更前**：

- 実弾数：1-3 発（可変）
- 装填上限：通常 6 発（実質的に固定）
- 用語の混乱：装填上限 vs 実弾数

**変更後**：

- **実弾数**：1 発固定（シンプル化）
- **装弾数**：6 発標準、設定可能（1-12 発程度）
- **確率**：実弾数/装弾数 = 1/6 (標準)

**用語統一**：

```
装弾数: シリンダー容量（6発が標準）
実弾数: 危険な弾の数（1発固定）
安全確率: (装弾数-実弾数)/装弾数
```

### 新アーキテクチャ設計

#### 主要コンポーネント

1. **言語管理システム** (`i18n.rs`)
2. **対話式 UI** (`interactive.rs`)
3. **プレイヤー管理** (`player_manager.rs`)
4. **ロシアンルーレット** (`roulette.rs` - 簡素化)
5. **設定管理** (`config.rs`)

#### データ構造

```rust
struct GameConfig {
    language: String,
    chamber_capacity: u8,  // 装填上限
    // 実弾数は常に1で固定
}

struct Player {
    id: u8,
    name: String,        // カスタム名前
    is_active: bool,
}
```

### 実装優先順位

#### Phase 2A: 基盤整備

1. **多言語システム**の実装
2. **設定管理機能**の実装
3. **対話式 UI 基盤**の構築

#### Phase 2B: 機能実装

1. **プレイヤー管理**の刷新
2. **ロシアンルーレット**の簡素化
3. **メインゲームフロー**の再実装

#### Phase 2C: 統合・テスト

1. **全機能の統合**
2. **多言語テスト**
3. **ユーザビリティテスト**

### 技術的課題と解決策

#### 課題 1: 対話式 UI の実装

**問題**: Rust での対話式 UI 実装の複雑さ
**解決策**: `dialoguer`クレートの採用を検討

#### 課題 2: 多言語管理

**問題**: 動的な言語切り替えとメッセージ管理
**解決策**: TOML ファイル + HashMap 構造での管理

#### 課題 3: 既存コードとの互換性

**問題**: 大幅な設計変更による既存コードの影響
**解決策**: 段階的移行とレガシーサポート

### 期待される効果

1. **使いやすさの大幅向上**：直感的な対話式操作
2. **国際化対応**：多様なユーザーベースへの対応
3. **実用性の向上**：実際のトランプゲームとの親和性
4. **複雑さの軽減**：シンプルなロシアンルーレット仕様

この抜本的な見直しにより、真に実用的で使いやすいツールへと進化させる。

- [ ] エラーハンドリング
- [ ] ユーザビリティ改善
- [ ] テスト実装

## 実装上の課題と解決策

### 課題 1: 公平性の確保

**問題**: ロシアンルーレットの結果が予測可能だと不公平
**解決策**: `rand::rngs::OsRng`を使用して暗号学的に安全な乱数を生成

### 課題 2: 状態管理の複雑さ

**問題**: 複数プレイヤーの手札と場の状態を正確に管理する必要
**解決策**: 構造体を使った明確な状態管理と immutable な操作

### 課題 3: ユーザビリティ

**問題**: CLI ツールとして使いやすくする必要
**解決策**: 直感的なサブコマンド設計と分かりやすいヘルプメッセージ

## 2025 年 7 月 26 日 夕方 - 追加検討事項

### 用語の再検討

**要望**: 「装填上限」より「装弾数」の方がかっこいい
**決定**: 全ドキュメントで用語を統一

- 変更前：装填上限
- 変更後：装弾数

### 言語ファイルの分離

**要望**: 各言語を独立したファイルで管理
**決定**: `languages/` ディレクトリに分離

- `languages/ja.toml` - 日本語
- `languages/en.toml` - 英語
- 将来的に他言語追加が容易

### メッセージキーの統一

**要望**: `welcome` → `welcome_msg` のような明確な命名
**決定**: 全メッセージキーを `_msg` サフィックスで統一

### 更新された設計

#### 新しいファイル構造

```
liars_table/
├── config.toml           # 基本設定のみ
├── languages/
│   ├── ja.toml          # 日本語メッセージ
│   └── en.toml          # 英語メッセージ
└── src/
    ├── i18n.rs          # 多言語システム
    └── ...
```

#### 用語統一表

| 旧用語           | 新用語          | 意味           |
| ---------------- | --------------- | -------------- |
| 装填上限         | 装弾数          | シリンダー容量 |
| chamber_capacity | bullet_capacity | 変数名         |
| welcome          | welcome_msg     | メッセージキー |

これらの変更により、より直感的で管理しやすい設計となった。

## 2025 年 7 月 26 日 夜 - セキュリティ要件の見直し

### 実用性重視の方針転換

**背景**: ローカル使用のゲームツールとしての用途を考慮し、過剰なセキュリティ対策を見直し

### セキュリティ要件の整理

#### 🚫 **不要な過剰セキュリティ**

1. **暗号学的乱数生成**

   - 変更前：`OsRng`（暗号学的に安全）
   - 変更後：`rand::thread_rng()`（標準的な品質）
   - 理由：ローカルゲームで暗号強度は不要

2. **SQL インジェクション対策**

   - 理由：データベース使用なし、TOML/JSON 設定のみ

3. **機密性保護**
   - 理由：ゲーム設定に機密情報なし

#### ✅ **必要な実用的品質**

1. **乱数品質**

   - 要件：予測困難、統計的偏りなし
   - 実装：`rand`クレートの標準実装で十分
   - Windows の実装品質を信頼

2. **入力検証・堅牢性**

   - 要件：不正入力でクラッシュしない
   - 対策：適切な入力検証とエラーハンドリング
   - 例：数値入力の範囲チェック、文字列長制限

3. **エラーハンドリング**
   - 要件：想定外状況でも動作継続
   - 実装：`Result`型による適切なエラー処理

### 新しい設計指針

#### 乱数生成の簡素化

```rust
// 変更前（過剰）
use rand::rngs::OsRng;
let mut rng = OsRng;

// 変更後（実用的）
use rand::thread_rng;
let mut rng = thread_rng();
```

#### 入力検証の重点化

```rust
// プレイヤー名の検証例
fn validate_player_name(name: &str) -> Result<String, ValidationError> {
    let trimmed = name.trim();
    if trimmed.is_empty() {
        return Err(ValidationError::EmptyName);
    }
    if trimmed.len() > 20 {
        return Err(ValidationError::NameTooLong);
    }
    Ok(trimmed.to_string())
}

// 装弾数の検証例
fn validate_bullet_capacity(capacity: u8) -> Result<u8, ValidationError> {
    match capacity {
        1..=12 => Ok(capacity),
        0 => Err(ValidationError::ZeroCapacity),
        _ => Err(ValidationError::CapacityTooLarge),
    }
}
```

### 実装への影響

#### Phase 2A での変更点

1. **乱数生成器の変更**

   - `OsRng` → `thread_rng()`
   - 依存関係の軽量化

2. **入力検証の強化**

   - 対話式 UI での堅牢な入力処理
   - エラーメッセージの多言語対応

3. **エラーハンドリング設計**
   - ユーザーフレンドリーなエラー表示
   - 回復可能なエラーでのゲーム継続

この方針により、適切な品質を保ちながら実装の複雑さを軽減し、実用性を重視した設計とする。
